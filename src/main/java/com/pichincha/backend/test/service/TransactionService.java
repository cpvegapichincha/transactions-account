package com.pichincha.backend.test.service;

import static com.pichincha.backend.test.Constants.TRANSACTION_NOT_FOUND;
import static org.springframework.http.HttpEntity.EMPTY;
import static org.springframework.http.HttpMethod.GET;

import com.pichincha.backend.test.dto.AccountResponseDto;
import com.pichincha.backend.test.dto.NewTransactionDto;
import com.pichincha.backend.test.dto.TransactionDto;
import com.pichincha.backend.test.dto.rest.TransactionContainer;
import com.pichincha.backend.test.exception.AccountNotFoundException;
import com.pichincha.backend.test.exception.TransactionsNotFoundException;
import com.pichincha.backend.test.iservices.IAccountService;
import com.pichincha.backend.test.iservices.ITransactionService;
import com.pichincha.backend.test.mapper.ServiceMapper;
import com.pichincha.backend.test.model.Account;
import com.pichincha.backend.test.model.Transaction;
import com.pichincha.backend.test.repository.TransactionRepository;
import com.pichincha.backend.test.util.ApiConsumer;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.stereotype.Service;

@Service
@Log4j2
public class TransactionService implements ITransactionService {

  @Autowired
  ApiConsumer apiConsumer;
  @Value("${api.url}")
  String url;
  @Autowired
  TransactionRepository repository;
  @Autowired
  ServiceMapper serviceMapper;
  @Autowired
  IAccountService iAccountService;

  //todo: create a new transaction in database, return the autogenerated id of the new transaction (service)
  //todo: before controller newTransactionDto's fields must be validated
  //todo: is this declared method in the correct class? explain why.
  @Override
  public UUID addTransaction(NewTransactionDto newTransactionDto, String accountId) {
    Account account = iAccountService.getDatabaseAccount(UUID.fromString(accountId));
    Transaction newTransaction = serviceMapper.toTransaction(newTransactionDto, account);
    return repository.save(newTransaction).getId();
  }

  //todo: return a list of transactions from database and consume API and return both results in a single object ordered by creation date descending and separated by type
  // extra point if mapping is made with functions
  //todo: https://run.mocky.io/v3/1ac36ba6-9535-484d-93b2-fd6c68044884 API if service does return OK but has no information it just returns an empty list
  //todo: API if service does return OK but has no information it just returns an empty list
  //todo: Validate status if 0 ok if not empty list
  @Override
  public Map<String, List<TransactionDto>> getTransactionsForAccount(UUID accountId) {
    List<TransactionDto> transactions = new ArrayList<>(consumeTransactionApi());
    List<Transaction> databaseTransactions = repository.findByAccountId(accountId);
    transactions.addAll(serviceMapper.toTransactionDtoListFromDatabase(databaseTransactions));
    Map<String, List<TransactionDto>> groupedTransactions = transactions.stream()
        .collect(Collectors.groupingBy(TransactionDto::getType));
    groupedTransactions.entrySet()
        .forEach(stringListEntry -> stringListEntry.setValue(stringListEntry.getValue().stream()
            .sorted(Comparator.comparing(TransactionDto::getCreationDate))
            .collect(Collectors.toList())));
    return groupedTransactions;
  }

  private List<TransactionDto> consumeTransactionApi() {
    TransactionContainer response = apiConsumer.consumeApiRest(url, GET,
        EMPTY, ParameterizedTypeReference.forType(TransactionContainer.class));
    if (response.getStatus().getCode().equals("0")) {
      return serviceMapper.toTransactionDtoList(response.getTransaction());
    }
    return new ArrayList<>();
  }

  //todo:get all transactions between amounts x and y of a given account; being x and y pathParameters of the API
  //todo:filter transactions via repository not by service.
  //todo: should amounts type be changed? explain why
  //todo: use custom exceptions to throw errors and not exceptions thrown by java; and handle some of them through try and catch and some of them globally (ExceptionHandler)
  //todo: log different kind of levels depending of the information needed (errors, informative, and tracing) the header pass by sleuth should be present in all logs
  //todo: should send an async message to any queue you prefer, this queue must only log the tracing information of the account that is being searched
  //todo: use "mapResponse" of "serviceMapper" in service layer
  @Override
  public AccountResponseDto getFilteredTransactions(UUID accountId, double minimum,
      double maximum) {
    List<Transaction> transactions = repository
        .findByAccountIdAndAmountBetween(accountId, minimum, maximum);
    try {
      return serviceMapper.mapResponse(transactions);
    } catch (AccountNotFoundException exception) {
      log.error("missing transactions for account");
      throw new TransactionsNotFoundException(TRANSACTION_NOT_FOUND);
    }
  }
}
