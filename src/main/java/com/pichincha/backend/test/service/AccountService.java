package com.pichincha.backend.test.service;


import static com.pichincha.backend.test.Constants.ACCOUNT_NOT_FOUND;
import static com.pichincha.backend.test.Constants.BODY_NOT_FOUND;
import static lombok.AccessLevel.PRIVATE;
import static org.springframework.http.HttpEntity.EMPTY;
import static org.springframework.http.HttpMethod.GET;

import com.pichincha.backend.test.dto.AccountDto;
import com.pichincha.backend.test.dto.NewTransactionDto;
import com.pichincha.backend.test.dto.TransactionDto;
import com.pichincha.backend.test.dto.rest.TransactionContainer;
import com.pichincha.backend.test.exception.ApiBodyException;
import com.pichincha.backend.test.exception.SearchedAccountNotFoundException;
import com.pichincha.backend.test.mapper.ServiceMapper;
import com.pichincha.backend.test.repository.AccountRepository;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import lombok.experimental.FieldDefaults;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.client.RestTemplate;

//todo: modify class to inject dependencies not via constructors
@Service
@FieldDefaults(level = PRIVATE)
public class AccountService {

  @Autowired
  AccountRepository accountRepository;
  @Autowired
  ServiceMapper serviceMapper;
  @Autowired
  RestTemplate restTemplate;
  @Value("${api.url}")
  String url;

  //todo: use single responsibility principle (mappers in different layer) return account with its transactions and handle with API standards and best practices when account not found
  public AccountDto getAccount(UUID id) {
    return accountRepository.findById(id)
        .map(account -> serviceMapper.toAccountDto(account))
        .orElseThrow(() -> new SearchedAccountNotFoundException(ACCOUNT_NOT_FOUND));
  }

  //todo: return a list of transactions from database and consume API and return both results in a single entity ordered by creation date descending and separated by type
  // extra point if all this is made with functions (+1)
  //todo: https://run.mocky.io/v3/1ac36ba6-9535-484d-93b2-fd6c68044884 API if service does return OK but has no information it just returns an empty list
  //todo: is this declared method in the correct class? explain why.
  public List<TransactionDto> getTransactionsForAccount(UUID accountId) {
    List<TransactionDto> apiResult = consumeApiRest();

    throw new UnsupportedOperationException();
  }

  private List<TransactionDto> consumeApiRest() {
    ResponseEntity<TransactionContainer> response = restTemplate.exchange(url, GET, EMPTY,
        ParameterizedTypeReference.forType(TransactionContainer.class));
    if (response.hasBody()) {
      if (response.getBody().getStatus().getCode().equals("0")) {
        return serviceMapper.toTransactionDtoList(response.getBody().getTransaction());
      }
      return new ArrayList<>();
    }
    throw new ApiBodyException(BODY_NOT_FOUND);
  }

  //todo: create a new transaction in database with best practices, use custom exceptions to handle errors; return the autogenerated id of the new transaction
  //todo: is this declared method in the correct class? explain why.
  //todo: before controller newTransactionDto's fields should be validated
  public Long addTransaction(NewTransactionDto newTransactionDto) {
    throw new UnsupportedOperationException();
  }

}
