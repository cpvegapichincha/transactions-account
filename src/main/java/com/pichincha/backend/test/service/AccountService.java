package com.pichincha.backend.test.service;


import com.pichincha.backend.test.dto.AccountDto;
import com.pichincha.backend.test.dto.NewTransactionDto;
import com.pichincha.backend.test.dto.TransactionDto;
import com.pichincha.backend.test.repository.AccountRepository;
import java.util.List;

//todo: modify class to inject dependencies not via constructors
public class AccountService {

  private final AccountRepository accountRepository;

  public AccountService(AccountRepository accountRepository) {
    this.accountRepository = accountRepository;
  }

  //todo: use single responsibility principle (mappers in different layer) return account with its transactions and handle with API standards and best practices when account not found
  public AccountDto getAccount(Long id) {
    return accountRepository.findById(id)
        .map(account -> new AccountDto(account.getNumber(), account.getType(),
            account.getCreationDate()))
        .orElse(null);
  }

  //todo: return a list of transactions from database and consume API and return both results in a single entity ordered by creation date descending and separated by type
  // extra point if all this is made with functions (+1)
  //todo: https://run.mocky.io/v3/1ac36ba6-9535-484d-93b2-fd6c68044884 API
  //todo: is this declared method in the correct class? explain why.
  public List<TransactionDto> getTransactionsForAccount(Long accountId) {
    throw new UnsupportedOperationException();
  }

  //todo: create a new transaction in database with best practices, use custom exceptions to handle errors; return the autogenerated id of the new transaction
  //todo: is this declared method in the correct class? explain why.
  //todo: before controller newTransactionDto's fields should be validated
  public Long addTransaction(NewTransactionDto newTransactionDto) {
    throw new UnsupportedOperationException();
  }

}
